options {
  IGNORE_CASE = true;
  STATIC = false;
}

PARSER_BEGIN(BasicParser)
package de.haupz.basicode.parser;

import java.util.ArrayList;
import java.util.List;

import de.haupz.basicode.ast.*;

public class BasicParser {}
PARSER_END(BasicParser)

// Lexer.

SKIP: {
    " "
}

TOKEN: {
// basics
    < EOL: "\n" >
|   < COLON: ":" >
// numbers and other values
|   < NUMBER: (<DIGIT>)+ >
|   < INTEGER: <NUMBER> >
|   < FLOAT: <NUMBER> "." <NUMBER> >
|   < DIGIT: ["0"-"9"] >
|   < STRING: "\"" (~["\"","\n"])* "\"" >
// keywords
|   < ABS: "ABS" > | < AND: "AND" > | < ASC: "ASC" > | < ATN: "ATN" >
|   < CHRS: "CHR$" > | < COS: "COS" >
|   < DATA: "DATA" > | < DIM: "DIM" >
|   < END: "END" >
|   < FOR: "FOR" >
|   < GOSUB: "GOSUB" > | < GOTO: "GOTO" >
|   < INT: "INT" > | < IF: "IF" > | < INPUT: "INPUT" >
|   < LEFTS: "LEFT$" > | < LEN: "LEN" > | < LET: "LET" > | < LOG: "LOG" >
|   < MIDS: "MID$" >
|   < NEXT: "NEXT" > | < NOT: "NOT" >
|   < ON: "ON" > | < OR: "OR" >
|   < PRINT: "PRINT" >
|   < READ: "READ" > | < REM: "REM" (~["\n"])* > // REM is special: it consumes all characters until the end of the line
|   < RESTORE: "RESTORE" > | < RETURN: "RETURN" > | < RIGHTS: "RIGHT$" > | < RUN: "RUN" >
|   < SGN: "SGN" > | < SIN: "SIN" > | < SQR: "SQR" > | < STEP: "STEP" > | < STOP: "STOP" >
|   < TAB: "TAB" > | < TAN: "TAN" > | < THEN: "THEN" > | < TO: "TO" >
|   < VAL: "VAL" >
// operands
|   < CARET: "^" >
|   < LT: "<" >
|   < GT: ">" >
|   < LEQ: "<=" >
|   < GEQ: ">=" >
// identifiers
|   < IDENTIFIER: ["a"-"z","A"-"Z"] ["a"-"z","A"-"Z","0"-"9"] >
}

// Parser.

//
// basic structures
//

ProgramNode program():
{
    List<LineNode> lines = new ArrayList<>();
    LineNode l;
}
{
    (l = line() { lines.add(l); })*
    { return new ProgramNode(lines); }
}

LineNode line():
{
    List<StatementNode> statements = new ArrayList<>();
    int num;
    StatementNode st;
}
{
    num = lineNumber()
    st = statement() { statements.add(st); }
    (<COLON> st = statement() { statements.add(st); })*
    (<EOL>|<EOF>)
    { return new LineNode(num, statements); }
}

int lineNumber():
{
    Token n;
}
{
    n = <NUMBER> { return Integer.parseInt(n.image); }
}

//
// statements
//

StatementNode statement():
{
    Token t;
    ExpressionNode e;
}
{
    t = <REM> { return new RemNode(t.image); }
|   <PRINT> e = expression() { return new PrintNode(e); }
}

//
// expressions
//

ExpressionNode expression():
{
    ExpressionNode e;
    ExpressionNode f;
    List<ExpressionNode> l = new ArrayList<>();
}
{
    e = and_expression() ( <OR> f = and_expression() { l.add(f); } )*
    { return l.isEmpty() ? e : new OrNode(e, l); }
}

ExpressionNode and_expression():
{
    ExpressionNode e;
    ExpressionNode f;
    List<ExpressionNode> l = new ArrayList<>();
}
{
    e = equality_expression() ( <AND> f = equality_expression() { l.add(f); } )*
    { return l.isEmpty() ? e : new AndNode(e, l); }
}

ExpressionNode equality_expression():
{
    ExpressionNode e;
    ExpressionNode f;
}
{
    e = relational_expression()
    (
        "=" f = relational_expression() { return new EqNode(e, f); }
    |   "<>" f = relational_expression() { return new NeqNode(e, f); }
    )?
    { return e; }
}

ExpressionNode relational_expression():
{
    ExpressionNode e;
    ExpressionNode f = null;
    Token t = null;
}
{
    e = additive_expression() ( (t=<LT>|t=<LEQ>|t=<GT>|t=<GEQ>) f = additive_expression() )?
    {
        if (null == f) {
            return e;
        } else if (t.kind == LT) {
            return new LtNode(e, f);
        } else if (t.kind == LEQ) {
            return new LeqNode(e, f);
        } else if (t.kind == GT) {
            return new GtNode(e, f);
        } else if (t.kind == GEQ) {
            return new GeqNode(e, f);
        } else {
            throw new IllegalStateException("unexpected token: " + t.image);
        }
    }
}

ExpressionNode additive_expression():
{
    ExpressionNode e;
    ExpressionNode f;
}
{
    e = multiplicative_expression()
    (
        "+" f = multiplicative_expression() { e = new AddNode(e, f); }
    |   "-" f = multiplicative_expression() { e = new SubtractNode(e, f); }
    )*
    { return e; }
}

ExpressionNode multiplicative_expression():
{
    ExpressionNode e;
    ExpressionNode f;
}
{
    e = unary_expression()
    (
        "*" f = unary_expression() { e = new MultiplyNode(e, f); }
    |   "/" f = unary_expression() { e = new DivideNode(e, f); }
    )*
    { return e; }
}

ExpressionNode unary_expression():
{
    ExpressionNode e;
}
{
    "-" e = unary_expression() { return new NegateNode(e); }
|   e = unary_expression_not_plus_minus() { return e; }
}

ExpressionNode unary_expression_not_plus_minus():
{
    ExpressionNode e;
}
{
    <NOT> e = unary_expression() { return new NotNode(e); }
|   e = primary_expression() { return e; }
}

ExpressionNode primary_expression():
{
    ExpressionNode e;
}
{
    e = literal() { return e; }
|   "(" e = expression() ")" { return e; }
|   e = builtin_call() { return e; }
}

ExpressionNode literal():
{
    Token t;
}
{
    (t = <NUMBER> | t = <INTEGER>) { return new IntegerNode(Integer.parseInt(t.image)); }
|   t = <FLOAT> { return new DoubleNode(Double.parseDouble(t.image)); }
|   t = <STRING> { return new StringNode(t.image.substring(1, t.image.length() - 1)); }
|   t = <IDENTIFIER> { return new StringNode(t.image); }
}

ExpressionNode builtin_call():
{
    ExpressionNode e;
    ExpressionNode f;
    ExpressionNode g;
}
{
    <ABS> "(" e = expression() ")" { return new AbsNode(e); }
|   <ASC> "(" e = expression() ")" { return new AscNode(e); }
|   <ATN> "(" e = expression() ")" { return new AtnNode(e); }
|   <CHRS> "(" e = expression() ")" { return new ChrsNode(e); }
|   <COS> "(" e = expression() ")" { return new CosNode(e); }
|   <INT> "(" e = expression() ")" { return new IntNode(e); }
|   <LEFTS> "(" e = expression() "," f = expression() ")" { return new LeftsNode(e, f); }
|   <MIDS> "(" e = expression() "," f = expression() "," g = expression() ")" { return new MidsNode(e, f, g); }
|   <RIGHTS> "(" e = expression() "," f = expression() ")" { return new RightsNode(e, f); }
|   <SGN> "(" e = expression() ")" { return new SgnNode(e); }
|   <SIN> "(" e = expression() ")" { return new SinNode(e); }
|   <SQR> "(" e = expression() ")" { return new SqrNode(e); }
|   <TAN> "(" e = expression() ")" { return new TanNode(e); }
|   <VAL> "(" e = expression() ")" { return new ValNode(e); }
}
